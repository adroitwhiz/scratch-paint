const lerp = (x0, x1, y0, y1, x) => y0 + (((y1 - y0) * (x - x0)) / (x1 - x0));

const pointsEqual = (p1, p2) => Math.abs(p1[0] - p2[0]) < 1e-12 &&
    Math.abs(p1[1] - p2[1]) < 1e-12;

/**
 * Trace a raster using the marching squares algorithm.
 * @param {ImageData} imageData The raster image data to trace
 * @returns {Array<Array<Array<number>>>} An array of line segments, each segment consisting of two points
 */
export const traceRaster = function (imageData) {
    const lines = [];

    const {width, height, data} = imageData;
    for (let i = 0; i < (width - 1) * (height - 1); i++) {
        let tlx = i % (width - 1);
        let tly = (i / (width - 1)) | 0;

        const tl = data[((tly * width) + tlx) * 4];
        const tr = data[((tly * width) + tlx + 1) * 4];
        const bl = data[(((tly + 1) * width) + tlx) * 4];
        const br = data[(((tly + 1) * width) + tlx + 1) * 4];

        const tlOn = tl > 127 ? 1 : 0;
        const trOn = tr > 127 ? 1 : 0;
        const blOn = bl > 127 ? 1 : 0;
        const brOn = br > 127 ? 1 : 0;

        // Prevent singularities from interpolated vertices merging into the same position
        const interpBottom = 1 / 255;
        const interpTop = 254 / 255;

        const topEdge = lerp(tl, tr, interpBottom, interpTop, 128);
        const leftEdge = lerp(tl, bl, interpBottom, interpTop, 128);
        const rightEdge = lerp(tr, br, interpBottom, interpTop, 128);
        const bottomEdge = lerp(bl, br, interpBottom, interpTop, 128);

        tlx += 0.5;
        tly += 0.5;

        const corners = (tlOn << 3) | (trOn << 2) | (blOn << 1) | brOn;

        let line1 = null;
        let line2 = null;

        switch (corners) {
        case 0b0010:
            line1 = [[tlx, tly + leftEdge], [tlx + bottomEdge, tly + 1]];
            break;
        case 0b0001:
            line1 = [[tlx + bottomEdge, tly + 1], [tlx + 1, tly + rightEdge]];
            break;
        case 0b0011:
            line1 = [[tlx, tly + leftEdge], [tlx + 1, tly + rightEdge]];
            break;
        case 0b0100:
            line1 = [[tlx + 1, tly + rightEdge], [tlx + topEdge, tly]];
            break;
        case 0b0110:
            line1 = [[tlx, tly + leftEdge], [tlx + topEdge, tly]];
            line2 = [[tlx + 1, tly + rightEdge], [tlx + bottomEdge, tly + 1]];
            break;
        case 0b0101:
            line1 = [[tlx + bottomEdge, tly + 1], [tlx + topEdge, tly]];
            break;
        case 0b0111:
            line1 = [[tlx, tly + leftEdge], [tlx + topEdge, tly]];
            break;
        case 0b1000:
            line1 = [[tlx + topEdge, tly], [tlx, tly + leftEdge]];
            break;
        case 0b1010:
            line1 = [[tlx + topEdge, tly], [tlx + bottomEdge, tly + 1]];
            break;
        case 0b1001:
            line1 = [[tlx + topEdge, tly], [tlx + 1, tly + rightEdge]];
            line2 = [[tlx + bottomEdge, tly + 1], [tlx, tly + leftEdge]];
            break;
        case 0b1011:
            line1 = [[tlx + topEdge, tly], [tlx + 1, tly + rightEdge]];
            break;
        case 0b1100:
            line1 = [[tlx + 1, tly + rightEdge], [tlx, tly + leftEdge]];
            break;
        case 0b1110:
            line1 = [[tlx + 1, tly + rightEdge], [tlx + bottomEdge, tly + 1]];
            break;
        case 0b1101:
            line1 = [[tlx + bottomEdge, tly + 1], [tlx, tly + leftEdge]];
            break;
        }

        // sometimes interpolated lines will have zero length, which messes up polyline merging-- don't add them
        if (line1 && !pointsEqual(line1[0], line1[1])) lines.push(line1);
        if (line2 && !pointsEqual(line2[0], line2[1])) lines.push(line2);
    }

    return lines;
};

// This seems like a bad algorithm that does unnecessary work, but it's better than the "smart" way on Firefox somehow
const mergeLine = function (line, polylines) {
    for (let i = 0; i < polylines.length; i++) {
        const polyline = polylines[i];

        // polyline's end point is the passed line's start point
        if (pointsEqual(polyline[polyline.length - 1], line[0])) {
            for (let j = 1; j < line.length; j++) {
                polyline.push(line[j]);
            }

            polylines.splice(i, 1);
            mergeLine(polyline, polylines);
            return;
        }

        // polyline's start point is the passed line's end point
        if (pointsEqual(polyline[0], line[line.length - 1])) {
            for (let j = line.length - 2; j >= 0; j--) {
                polyline.unshift(line[j]);
            }

            polylines.splice(i, 1);
            mergeLine(polyline, polylines);
            return;
        }
    }

    polylines.push(line);
};

/**
 * Combine individual line segments generated by the marching squares algorithm into polylines
 * @param {Array<Array<Array<number>>>} lines An array of line segments, each line segment consisting of two points
 * @returns {Array<Array<Array<number>>>} An array of polylines, each polyline consisting of multiple points.
 * Polylines that represent holes will be oriented counterclockwise; all others will be clockwise.
 * Polylines' first points and last points will be identical.
 */
export const combinePolylines = function (lines) {
    const polylines = [];

    for (let i = 0; i < lines.length; i++) {
        mergeLine(lines[i], polylines);
    }

    return polylines;
};
